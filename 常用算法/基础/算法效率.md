# 算法效率

- 算法操作速度不取决于执行的时间，而是取决于步数。因为不同性能的机器，运行算法的时间各不相同，这样会使得最终得到的算法时间不具备普遍性。通过比较步数，而得到衡定的执行步数，以确保算法可靠。操作的速度，称为时间复杂度，速度、效率、性能均指向效率。

## 读取

### 数组/集合

时间复杂度：1步

原因：

- 计算机可以一步跳到任意一个内存低智商
- 数组本身会记住第一个格子的内存地址。因此，计算机知道这个数组的开头在哪里
- 数组的索引从0开始。

## 查找

### 数组/集合

时间复杂度：N步（N是数组的长度，最多）

分析：对于数组，查找从索引0开始，最佳情况，索引0正好是想要的那个值，最坏情况，要查找的值不在数组中，这时要运行N步才能确定。

### 有序数组

> 注意其与普通数组的区别，实际上，如果查找到不符合顺序，即可返回false, 远远小于N步。有序数组比普通数组的查找要快。

时间复杂度：N步（N是数组的长度，最多）

## 插入

### 数组

时间复杂度：N+1步（N是数组的长度，最多）

分析：对于数组，最好情况是插入到尾部，只需要插入1步。最坏情况，向索引0位置插入，需要将数组原有元素全部右移1位（移动N次），最后将新数据插入到索引0的位置，即N+1步

### 集合

> 特点：为保证集合中元素都是唯一的，在插入之前，需要先做一遍查找。

时间复杂度 2N+1步（N是集合的长度，最多）

分析：对于集合，最好情况是插入到尾部，需要插入N+1步——先检查集合中是否存在待插入元素（N步），然后插入；最坏情况，将元素插入到集合头——检查完毕之后，将所有元素右移（N步），然后插入，花费2N+1步

## 删除

### 数组/集合

时间复杂度：N步（N是数组的长度，最多）

分析：对于数组，最好情况是删除末尾元素，仅需要1步。最坏情况，删除索引0位置，执行删除操作之后，需要将剩余元素全部左移1位（N-1），最终要执行N步。

## 大O记法

- 大O记法不关注算法所用的时间，只关注其所用的步数。
- 大O一般记的是最坏情况。比如数组查找，最好情况是O(1)，最坏情况是O(N)，那么，取最坏情况，即O(N)
- 大O记法忽略常数：大O记法不包含一般数字，除非是指数。比如O(N+1)，直接记为O(N)
- 大O只关心最高指数N，低指数舍弃。比如最坏执行部署是O(N^4 + N)，那么直接记为O(N^4)
- 两种时间
  - 线性时间：数据越多，算法所需要的时间越多，比如O(N)
  - 常数时间：不管数据量是多少，算法的步数是恒定的，比如O(1)。如果是O(3)这种，我们一般省略为O(1)。因为大O记法表现的是执行步数随着数据量变化情况。对于O(3)来说，再多数据，也是3步，实际上并没有比较意义。
- 示例：比如数组查找，对于一个长度为N的数组，最多需要N步，那么记为O(N)，读作"O N"

### 对数

- 对数是指数的反函数
- log2(8) --> 2 * 2 * 2 --> 2^3 = 8
  - 将2乘以多少次，能得到8
  - 将8不断除以2，以得到1，需要除以多少遍

## 循环

- 一次循环 O(N)
- 嵌套循环 O(N^2)