# 2021-02-01

## 1. [将字符串翻转到单调递增](https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/)

题号：926

### 我的题解

```js
/**
 * @param {string} S
 * @return {number}
 * 输入：字符串
 * 输出：最小翻转次数
 * 输入条件：
 *  - 1<=S.length<20000
 *  - S中只包含字符'0'或'1'
 * 输出条件：
 *  - 0后全是1或者全是0，则认为是单调递增
 *  - 最小翻转次数
 * 思路：
 *  - 迭代字符串数组
 *  - 当前数组项和下一位数组项只能是'01'和'00'组合，如果不是，则翻转不符合该规则的项
 */
var minFlipsMonoIncr = function(S) {
    let ans = 0;
    let one = 0;
    let n = S.length;
    for(let i = 0; i<n; i++){
        if(S[i]=='0'){
            ans++;
        }else{
            one++;
        }

        ans = Math.min(ans, one);
    }
    return ans;
};
```

执行用时：88 ms, 在所有 JavaScript 提交中击败了82.14%的用户

内存消耗：38.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户

### 最小执行时间

```js
/**
 * @param {string} S
 * @return {number}
 */
var minFlipsMonoIncr = function (S) {
  let zero = 0
  let one = 0
  for (let letter of S) {
    if (letter == '1') {
      ;[one, zero] = [Math.min(one, zero), zero + 1]
    } else {
      one = Math.min(one, zero) + 1
    }
  }
  return Math.min(one, zero)
}
```

### 最小内存

```js
/**
 * @param {string} S
 * @return {number}
 */
var minFlipsMonoIncr = function(S) {
    let min = 0, zero = 0, n = S.length-1, s = S[n];
    while(n>=0){
        let m = 0;
        while(S[n] == s) {m++,n--;}
        if(s == '0') zero += m;
        else min = Math.min(min+m,zero);
        s = S[n];
    }
    return min;
};
```

- 没懂题目，最为致命 >_<
- 前缀和算法