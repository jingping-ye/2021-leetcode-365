# 2021-04-21

## [寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

题号：#287

### 我的解法

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
    let set = new Set();
    for(let i=0;i<nums.length; i++){
        if(!set.has(nums[i])){
            set.add(nums[i]);
        }else{
            return nums[i]
        }
    }
};
```

执行用时：80 ms, 在所有 JavaScript 提交中击败了91.82%的用户

内存消耗：39.7 MB, 在所有 JavaScript 提交中击败了48.28%的用户

### 最少用时

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
    const hash = {}
    for (let i = 0; i < nums.length; i++) {
        if (!hash[nums[i]]) {
            hash[nums[i]] = true
        } else {
            return nums[i]
        }
    }
};
```

### 最小内存

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
    // nums数组中有n+1个数，从1到n，有一个数字重复
    // 找出nums数组中的最小值1和最大值n
    let lo = 1;
    let hi = nums.length - 1;
    while(lo < hi){
        const mid = Math.floor((lo + hi) / 2);
        let count = 0;
        for(var i = 0; i < nums.length; i++){
            if(nums[i] <= mid) count++;
        }
        if(count <= mid) lo = mid + 1;
        else hi = mid;
    }
    return lo;
};
```

### 我的思考

该题解题方法有：

1. 遍历循环对比。空间复杂度O(1)，时间复杂度O(n^2)
2. 排序后比较相邻项。空间复杂度O(1)，时间复杂度O(nlog(n))
3. 二分查找。空间复杂度O(1)，时间复杂度O(nlog(n))
4. 位运算。空间复杂度O(1)，时间复杂度O(n*32)
5. set。空间复杂度O(n),时间复杂度O(n)
6. 双指针法（龟兔赛跑）。时间复杂度O(1),空间复杂度O(n)
#### 
