# 2021-03-21

## 1.[编辑距离](https://leetcode-cn.com/problems/edit-distance/)

题号：#72

### 我的解答(大佬的)

```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function (word1, word2) {
  let m = word1.length;
  let n = word2.length;
  let dp = Array.from(Array(m + 1), () => Array(n + 1).fill(0));

  const min = function (a, b, c) {
    return Math.min(a, Math.min(b, c));
  };

  // 设置base case
  for (let i = 1; i <= m; i++) {
    dp[i][0] = i;
  }

  for (let j = 1; j <= n; j++) {
    dp[0][j] = j;
  }

  // 自底向上求解
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1);
      }
    }
  }

  return dp[m][n];
};

```

执行用时：136 ms, 在所有 JavaScript 提交中击败了28.74%的用户

内存消耗：42.7 MB, 在所有 JavaScript 提交中击败了56.20%的用户

### 最少耗时

```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
    let len1 = word1.length;
    let len2 = word2.length;
    let dp = new Array(len1+1).fill(0);

    if (len1 * len2 === 0) return len1 + len2;

    for (let i = 0; i <= len1; i++) {
        dp[i] = new Array(len2+1).fill(0);
        dp[i][0] = i;
    }
    for (let j = 0; j <= len2; j++) {
        dp[0][j] = j;
    }

    for (let i = 1; i <= len1; i++) {
        for (let j = 1; j <= len2; j++) {
            if (word1.charAt(i-1) === word2.charAt(j-1)) {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = Math.min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1;
            }
        }
    }

    return dp[len1][len2];
};
```

### 最小内存

```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(left, right) {
    const array = [];
    const charCodeCache = [];
    if (left === right) {
		return 0;
	}

	const swap = left;

	// Swapping the strings if `a` is longer than `b` so we know which one is the
	// shortest & which one is the longest
	if (left.length > right.length) {
		left = right;
		right = swap;
	}

	let leftLength = left.length;
	let rightLength = right.length;

	// Performing suffix trimming:
	// We can linearly drop suffix common to both strings since they
	// don't increase distance at all
	// Note: `~-` is the bitwise way to perform a `- 1` operation
	while (leftLength > 0 && (left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength))) {
		leftLength--;
		rightLength--;
	}

	// Performing prefix trimming
	// We can linearly drop prefix common to both strings since they
	// don't increase distance at all
	let start = 0;

	while (start < leftLength && (left.charCodeAt(start) === right.charCodeAt(start))) {
		start++;
	}

	leftLength -= start;
	rightLength -= start;

	if (leftLength === 0) {
		return rightLength;
	}

	let bCharCode;
	let result;
	let temp;
	let temp2;
	let i = 0;
	let j = 0;

	while (i < leftLength) {
		charCodeCache[i] = left.charCodeAt(start + i);
		array[i] = ++i;
	}

	while (j < rightLength) {
		bCharCode = right.charCodeAt(start + j);
		temp = j++;
		result = j;

		for (i = 0; i < leftLength; i++) {
			temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1;
			temp = array[i];
			// eslint-disable-next-line no-multi-assign
			result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
		}
	}

	return result;
};
```

- 看不懂，先记录，后续再看

分析如下：

basecase：s1为空，s2有长度；或者，s2为空，s1有空度，这时候basecase只需要插入另一个字符串的长度；

对于每对字符`s[i]`和`s[j]`， 可以有4种操作：

```js
if s1[i] === s2[j]:
	skip(跳过，不操作)
	 i, j 直接向前移动
 else:
 	三选一:
		insert(插入);
		删除(delete);
        替换(replace);
```

- 状态：指针i和j，指向字符串的长度变化
- 选择：skip|insert|delete|replace
- `dp[i][j]`：两个字符的最小编辑距离，i和j是由后往前的

```js
// 本来就相等，那么无需做任何操作，将之前的状态转移过来即可
if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
}
```

```js
// 删除
// 直接将word1[i]字符删除，前移i，继续与j对比,
// 操作数+1
dp[i - 1][j] + 1 

// 插入
// 直接在word1[i]插入与word2[j]一样的字符
// word2[j]被匹配，前移j，继续与i对比
// 操作数+1
dp[i][j - 1] + 1

// 替换
// 直接将word1[i]匹配为word2[j]，前移i, j继续对比
// 操作数+1
dp[i - 1][j - 1] + 1;
```

